[{"name":"call-to-getwd","author":"@ursachec","title":"Dangerous function getwd() used","description":"\n Avoid the `getwd` function, it does not check buffer lengths.\n Use `getcwd` instead, as it checks the buffer size.\n","score":4.0,"docStartLine":147,"traversal":{},"docEndLine":151,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"call-to-strtok","author":"@tuxology","title":"Dangerous function strtok() used","description":"\n Avoid `strtok` function as it modifies the original string in place\n and appends a null character after each token. This makes the\n original string unsafe. Suggested alternative is `strtok_r` with\n `saveptr`.\n","score":4.0,"docStartLine":128,"traversal":{},"docEndLine":132,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"call-to-strcpy","author":"@tuxology","title":"Dangerous functions `strcpy` or `strncpy` used","description":"\n Avoid `strcpy` or `strncpy` function. `strcpy` does not check buffer\n lengths.\n A possible mitigation could be `strncpy` which could prevent\n buffer overflows but does not null-terminate strings leading to\n memory corruption. A secure alternative (on BSD) is `strlcpy`.\n","score":4.0,"docStartLine":107,"traversal":{},"docEndLine":111,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"call-to-strcat","author":"@tuxology","title":"Dangerous functions `strcat` or `strncat` used","description":"\n Avoid `strcat` or `strncat` functions. These can be used insecurely\n causing non null-termianted strings leading to memory corruption.\n A secure alternative is `strcat_s`.\n","score":4.0,"docStartLine":85,"traversal":{},"docEndLine":89,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"call-to-scanf","author":"@tuxology","title":"Insecure function scanf() used","description":"\n Avoid `scanf` function as it can lead to reads beyond buffer\n boundary and cause buffer overflows. A secure alternative is `fgets`.\n","score":4.0,"docStartLine":65,"traversal":{},"docEndLine":69,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"format-controlled-printf","author":"@tuxology","title":"Non-constant format string passed to printf/sprintf/vsprintf","description":"\n Avoid user controlled format strings like \"argv\" in printf, sprintf and vsprintf \n functions as they can cause memory corruption. Some secure\n alternatives are `snprintf` and `vsnprintf`.\n","score":4.0,"docStartLine":41,"traversal":{},"docEndLine":50,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"call-to-gets","author":"@tuxology","title":"Dangerous function gets() used","description":"\n Avoid `gets` function as it can lead to reads beyond buffer\n boundary and cause\n buffer overflows. Some secure alternatives are `fgets` and `gets_s`.\n","score":8.0,"docStartLine":21,"traversal":{},"docEndLine":25,"docFileName":"DangerousFunctions.scala","tags":[]},{"name":"strncpy-no-null-term","author":"@fabsx00","title":"strncpy is used and no null termination is nearby","description":"\n Upon calling `strncpy` with a source string that is larger\n than the destination buffer, the destination buffer is not\n null-terminated by `strncpy` and there is no explicit\n null termination nearby. This is unproblematic if the\n buffer size is at least 1 larger than the size passed\n to `strncpy`.\n","score":4.0,"docStartLine":26,"traversal":{},"docEndLine":46,"docFileName":"NullTermination.scala","tags":[]},{"name":"malloc-memcpy-int-overflow","author":"@fabsx00","title":"Dangerous copy-operation into heap-allocated buffer","description":"-","score":4.0,"docStartLine":25,"traversal":{},"docEndLine":44,"docFileName":"HeapBasedOverflow.scala","tags":[]},{"name":"copy-loop","author":"@fabsx00","title":"Copy loop detected","description":"\nFor (buf, indices) pairs, determine those inside control structures (for, while, if ...)\nwhere any of the calls made outside of the body (block) are Inc operations. Determine\nthe first argument of that Inc operation and check if they are used as indices for\nthe write operation into the buffer.\n","score":2.0,"docStartLine":22,"traversal":{},"docEndLine":40,"docFileName":"CopyLoops.scala","tags":[]},{"name":"unchecked-read-recv","author":"@fabsx00","title":"Unchecked read/recv","description":"\nThe return value of a read/recv call is not checked directly and the\nvariable its return value has been assigned to (if any) does not\noccur in any check within the caller.\n","score":3.0,"docStartLine":21,"traversal":{},"docEndLine":35,"docFileName":"RetvalChecks.scala","tags":[]},{"name":"free-field-no-reassign","author":"@fabsx00","title":"A field of a parameter is free'd and not reassigned on all paths","description":"\n The function is able to modify a field of a structure passed in by\n the caller. It frees this field and does not guarantee that on\n all paths to the exit, the field is reassigned. If any\n caller now accesses the field, then it accesses memory that is no\n longer allocated. We also check that the function does not free\n the entire structure, as in that case, it is unlikely that the\n passed in structure will be used again.\n","score":5.0,"docStartLine":27,"traversal":{},"docEndLine":51,"docFileName":"UseAfterFree.scala","tags":[]},{"name":"too-nested","author":"@fabsx00","title":"Nesting level higher than 3","description":"This query identifies functions with a nesting level higher than 3","score":1.0,"docStartLine":97,"traversal":{},"docEndLine":101,"docFileName":"Metrics.scala","tags":[]},{"name":"too-many-loops","author":"@fabsx00","title":"More than 4 loops","description":"This query identifies functions with more than 4 loops","score":1.0,"docStartLine":79,"traversal":{},"docEndLine":85,"docFileName":"Metrics.scala","tags":[]},{"name":"multiple-returns","author":"@fabsx00","title":"Multiple returns","description":"This query identifies functions with more than one return","score":1.0,"docStartLine":64,"traversal":{},"docEndLine":68,"docFileName":"Metrics.scala","tags":[]},{"name":"too-long","author":"@fabsx00","title":"More than 1000 lines","description":"This query identifies functions that are more than 1000 lines long","score":1.0,"docStartLine":49,"traversal":{},"docEndLine":53,"docFileName":"Metrics.scala","tags":[]},{"name":"too-high-complexity","author":"@fabsx00","title":"Cyclomatic complexity higher than 4","description":"This query identifies functions with a cyclomatic complexity higher than 4","score":1.0,"docStartLine":33,"traversal":{},"docEndLine":37,"docFileName":"Metrics.scala","tags":[]},{"name":"too-many-params","author":"@fabsx00","title":"Number of parameters larger than 4","description":"This query identifies functions with more than 4 formal parameters","score":1.0,"docStartLine":17,"traversal":{},"docEndLine":21,"docFileName":"Metrics.scala","tags":[]},{"name":"strlen-truncation","author":"@fabsx00","title":"Truncation in assignment involving `strlen` call","description":"\nThe return value of `strlen` is stored in a variable that is known\nto be of type `int` as opposed to `size_t`. `int` is only 32 bit\nwide on many 64 bit platforms, and thus, this may result in a\ntruncation.\n","score":2.0,"docStartLine":27,"traversal":{},"docEndLine":35,"docFileName":"IntegerTruncations.scala","tags":[]}]