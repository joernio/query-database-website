[{"name":"strncpy-no-null-term","author":"@fabsx00","title":"strncpy is used and no null termination is nearby","description":"\n Upon calling `strncpy` with a source string that is larger\n than the destination buffer, the destination buffer is not\n null-terminated by `strncpy` and there is no explicit\n null termination nearby. This is unproblematic if the\n buffer size is at least 1 larger than the size passed\n to `strncpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val allocations = cpg.method(\".*malloc$\").callIn.argument(1).l\n        cpg\n          .method(\"strncpy\")\n          .callIn\n          .map { c =>\n            (c.method, c.argument(1), c.argument(3))\n          }\n          .filter {\n            case (method, dst, size) =>\n              dst.reachableBy(allocations).codeExact(size.code).nonEmpty &&\n                method.assignments\n                  .where(_.target.isArrayAccess.code(s\"${dst.code}.*\\\\[.*\"))\n                  .source\n                  .isLiteral\n                  .code(\".*0.*\")\n                  .isEmpty\n          }\n          .map(_._2)","tags":["strings"]},{"name":"free-follows-value-reuse","author":"@maltek","title":"A value that is free'd is reused without reassignment.","description":"\nA value is used after being free'd in a path that leads to it\nwithout reassignment.\n\nModeled after CVE-2019-18903.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method\n          .name(\"(.*_)?free\")\n          .filter(_.parameter.size == 1)\n          .callIn\n          .where(_.argument(1).isIdentifier)\n          .flatMap(f => {\n            val freedIdentifierCode = f.argument(1).code\n            val postDom = f.postDominatedBy.toSet\n\n            val assignedPostDom = postDom.isIdentifier\n              .where(_.inAssignment)\n              .codeExact(freedIdentifierCode)\n              .flatMap(id => id ++ id.postDominatedBy)\n\n            postDom\n              .removedAll(assignedPostDom)\n              .isIdentifier\n              .codeExact(freedIdentifierCode)\n          })","tags":["uaf"]},{"name":"free-returned-value","author":"@maltek","title":"A value that is returned through a parameter is free'd in a path","description":"\nThe function sets a field of a function parameter to a value of a local\nvariable.\nThis variable is then freed in some paths. Unless the value set in the\nfunction |parameter is overridden later on, the caller has access to the\nfree'd memory, which is undefined behavior.\n\nFinds bugs like CVE-2019-18902.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        def outParams =\n          cpg.parameter\n            .typeFullName(\".+\\\\*\")\n            .whereNot(\n              _.referencingIdentifiers\n                .argumentIndex(1)\n                .inCall\n                .nameExact(Operators.assignment, Operators.addressOf))\n\n        def assignedValues =\n          outParams.referencingIdentifiers\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.indirectFieldAccess,\n                       Operators.indirection,\n                       Operators.indirectIndexAccess)\n            .argumentIndex(1)\n            .inCall\n            .nameExact(Operators.assignment)\n            .argument(2)\n            .isIdentifier\n\n        def freeAssigned =\n          assignedValues\n            .map(\n              id =>\n                (id,\n                 id.refsTo\n                   .flatMap {\n                     case p: MethodParameterIn => p.referencingIdentifiers\n                     case v: Local             => v.referencingIdentifiers\n                   }\n                   .inCall\n                   .name(\"(.*_)?free\")))\n\n        freeAssigned\n          .filter {\n            case (id, freeCall) => freeCall.dominatedBy.exists(_ == id)\n          }\n          .flatMap(_._1)","tags":["uaf"]},{"name":"free-field-no-reassign","author":"@fabsx00","title":"A field of a parameter is free'd and not reassigned on all paths","description":"\n The function is able to modify a field of a structure passed in by\n the caller. It frees this field and does not guarantee that on\n all paths to the exit, the field is reassigned. If any\n caller now accesses the field, then it accesses memory that is no\n longer allocated. We also check that the function does not free\n or clear the entire structure, as in that case, it is unlikely that the\n passed in structure will be used again.\n","score":5.0,"traversal":{},"traversalAsString":"cpg =>\n        val freeOfStructField = cpg\n          .method(\"free\")\n          .callIn\n          .where(\n            _.argument(1)\n              .isCallTo(\"<operator>.*[fF]ieldAccess.*\")\n              .filter(x =>\n                x.method.parameter.name.toSet.contains(x.argument(1).code))\n          )\n          .whereNot(_.argument(1).isCall.argument(1).filter { struct =>\n            struct.method.ast.isCall\n              .name(\".*free$\", \"memset\", \"bzero\")\n              .argument(1)\n              .codeExact(struct.code)\n              .nonEmpty\n          })\n          .l\n\n        freeOfStructField.argument(1).filter { arg =>\n          arg.method.methodReturn.reachableBy(arg).nonEmpty\n        }","tags":["uaf"]},{"name":"call-to-exec","author":"@0x4D5A","title":"Dangerous function 'java.lang.Runtime.exec:java.lang.Process(java.lang.String)' used","description":"\n A call to the function `java.lang.Runtime.exec:java.lang.Process(java.lang.String)` \n could result in a potential remote code execution.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"java.lang.Runtime.exec\")\n          .callIn","tags":[]},{"name":"copy-loop","author":"@fabsx00","title":"Copy loop detected","description":"\nFor (buf, indices) pairs, determine those inside control structures (for, while, if ...)\nwhere any of the calls made outside of the body (block) are Inc operations. Determine\nthe first argument of that Inc operation and check if they are used as indices for\nthe write operation into the buffer.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.assignment.target.isArrayAccess\n          .map { access =>\n            (access.array, access.subscripts.code.toSet)\n          }\n          .filter {\n            case (buf, subscripts) =>\n              val incIdentifiers = buf.inAst.isControlStructure.astChildren\n                .filterNot(_.isBlock)\n                .assignments\n                .target\n                .code\n                .toSet\n              (incIdentifiers & subscripts).nonEmpty\n          }\n          .map(_._1)","tags":[]},{"name":"signed-left-shift","author":"@maltek","title":"Signed Shift May Cause Undefined Behavior","description":"\nSigned integer overflow is undefined behavior. Shifts of signed values to the\nleft are very prone to overflow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.call\n          .nameExact(Operators.shiftLeft, Operators.assignmentShiftLeft)\n          .where(_.argument(1).typ.fullNameExact(\"int\", \"long\"))\n          .filterNot(_.argument.isLiteral.size == 2)","tags":[]},{"name":"strlen-truncation","author":"@fabsx00","title":"Truncation in assignment involving `strlen` call","description":"\nThe return value of `strlen` is stored in a variable that is known\nto be of type `int` as opposed to `size_t`. `int` is only 32 bit\nwide on many 64 bit platforms, and thus, this may result in a\ntruncation.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"strlen\")\n          .callIn\n          .inAssignment\n          .target\n          .evalType(\"(g?)int\")","tags":["integers"]},{"name":"too-nested","author":"@fabsx00","title":"Nesting level higher than 3","description":"This query identifies functions with a nesting level higher than 3","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.depth(_.isControlStructure) > n)","tags":["metrics"]},{"name":"too-many-loops","author":"@fabsx00","title":"More than 4 loops","description":"This query identifies functions with more than 4 loops","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal\n          .filter(\n            _.ast.isControlStructure\n              .parserTypeName(\"(For|Do|While).*\")\n              .size > n)","tags":["metrics"]},{"name":"multiple-returns","author":"@fabsx00","title":"Multiple returns","description":"This query identifies functions with more than one return","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.ast.isReturn.l.size > 1)","tags":["metrics"]},{"name":"too-long","author":"@fabsx00","title":"More than 1000 lines","description":"This query identifies functions that are more than 1000 lines long","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.numberOfLines > n)","tags":["metrics"]},{"name":"too-high-complexity","author":"@fabsx00","title":"Cyclomatic complexity higher than 4","description":"This query identifies functions with a cyclomatic complexity higher than 4","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.controlStructure.size > n)","tags":["metrics"]},{"name":"too-many-params","author":"@fabsx00","title":"Number of parameters larger than 4","description":"This query identifies functions with more than 4 formal parameters","score":1.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method.internal.filter(_.parameter.size > n)","tags":["metrics"]},{"name":"unchecked-read-recv-malloc","author":"@fabsx00","title":"Unchecked read/recv/malloc","description":"\nThe return value of a read/recv/malloc call is not checked directly and\nthe variable it has been assigned to (if any) does not\noccur in any check within the caller.\n","score":3.0,"traversal":{},"traversalAsString":"cpg =>\n        implicit val noResolve: NoResolve.type = NoResolve\n        val callsNotDirectlyChecked = cpg\n          .method(\"(read|recv|malloc)\")\n          .callIn\n          .filterNot { y =>\n            val code = y.code\n            y.inAstMinusLeaf.isControlStructure.condition.code.exists { x =>\n              x.contains(code)\n            }\n          }\n          .l\n\n        callsNotDirectlyChecked.filterNot { call =>\n          val inConditions = call.method.controlStructure.condition.ast.l;\n          val checkedVars = inConditions.isIdentifier.name.toSet ++ inConditions.isCall.code.toSet;\n          val targets = call.inAssignment.target.code.toSet\n          (targets & checkedVars).nonEmpty\n        }","tags":[]},{"name":"malloc-memcpy-int-overflow","author":"@fabsx00","title":"Dangerous copy-operation into heap-allocated buffer","description":"-","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        val src = cpg\n          .method(\".*malloc$\")\n          .callIn\n          .where(_.argument(1).arithmetics)\n          .l\n\n        cpg\n          .method(\"memcpy\")\n          .callIn\n          .l\n          .filter { memcpyCall =>\n            memcpyCall\n              .argument(1)\n              .reachableBy(src)\n              .where(\n                _.inAssignment.target.codeExact(memcpyCall.argument(1).code))\n              .whereNot(_.argument(1).codeExact(memcpyCall.argument(3).code))\n              .hasNext\n          }","tags":["integers"]},{"name":"call-to-getwd","author":"@ursachec","title":"Dangerous function getwd() used","description":"\n Avoid the `getwd` function, it does not check buffer lengths.\n Use `getcwd` instead, as it checks the buffer size.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"getwd\").callIn","tags":["badfn"]},{"name":"call-to-strtok","author":"@tuxology","title":"Dangerous function strtok() used","description":"\n Avoid `strtok` function as it modifies the original string in place\n and appends a null character after each token. This makes the\n original string unsafe. Suggested alternative is `strtok_r` with\n `saveptr`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"strtok\").callIn","tags":["badfn"]},{"name":"call-to-strcpy","author":"@tuxology","title":"Dangerous functions `strcpy` or `strncpy` used","description":"\n Avoid `strcpy` or `strncpy` function. `strcpy` does not check buffer\n lengths.\n A possible mitigation could be `strncpy` which could prevent\n buffer overflows but does not null-terminate strings leading to\n memory corruption. A secure alternative (on BSD) is `strlcpy`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(strcpy|strncpy)\").callIn","tags":["badfn"]},{"name":"call-to-strcat","author":"@tuxology","title":"Dangerous functions `strcat` or `strncat` used","description":"\n Avoid `strcat` or `strncat` functions. These can be used insecurely\n causing non null-termianted strings leading to memory corruption.\n A secure alternative is `strcat_s`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"(strcat|strncat)\").callIn","tags":["badfn"]},{"name":"call-to-scanf","author":"@tuxology","title":"Insecure function scanf() used","description":"\n Avoid `scanf` function as it can lead to reads beyond buffer\n boundary and cause buffer overflows. A secure alternative is `fgets`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"scanf\").callIn","tags":["badfn"]},{"name":"format-controlled-printf","author":"@tuxology","title":"Non-constant format string passed to printf/sprintf/vsprintf","description":"\n Avoid user controlled format strings like \"argv\" in printf, sprintf and vsprintf \n functions as they can cause memory corruption. Some secure\n alternatives are `snprintf` and `vsnprintf`.\n","score":4.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"printf\")\n          .callIn\n          .whereNot(_.argument.order(1).isLiteral) ++\n          cpg\n            .method(\"(sprintf|vsprintf)\")\n            .callIn\n            .whereNot(_.argument.order(2).isLiteral)","tags":["badfn"]},{"name":"call-to-gets","author":"@tuxology","title":"Dangerous function gets() used","description":"\n Avoid `gets` function as it can lead to reads beyond buffer\n boundary and cause\n buffer overflows. Some secure alternatives are `fgets` and `gets_s`.\n","score":8.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg.method(\"gets\").callIn","tags":["badfn"]},{"name":"setgid-without-setgroups","author":"@maltek","title":"Process group membership is changed without setting ancillary groups first","description":"\nThe set*gid system calls do not affect the ancillary groups a process belongs to.\nChanges to the group membership should therefore always be preceded by a call to setgroups.\nOtherwise the process may still be a secondary member of the group it tries to disavow.\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"set(res|re|e|)gid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"setgroups\"))","tags":["setxid"]},{"name":"setuid-without-setgid","author":"@maltek","title":"Process user ID is changed without changing groups first","description":"\nThe set*uid system calls do not affect the groups a process belongs to. However, often\nthere exists a group that is equivalent to a user (e.g. wheel or shadow groups are often\nequivalent to the root user).\nGroup membership can only be changed by the root user.\nChanges to the user should therefore always be preceded by calls to set*gid and setgroups,\n","score":2.0,"traversal":{},"traversalAsString":"cpg =>\n        cpg\n          .method(\"set(res|re|e|)uid\")\n          .callIn\n          .whereNot(_.dominatedBy.isCall.name(\"set(res|re|e|)?gid\"))","tags":["setxid"]}]